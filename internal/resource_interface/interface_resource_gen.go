// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_interface

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func InterfaceResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Default:  stringdefault.StaticString("interfaces.eda.nokia.com/v1alpha1"),
			},
			"kind": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Default:  stringdefault.StaticString("Interface"),
			},
			"metadata": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"annotations": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"labels": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"name": schema.StringAttribute{
						Required: true,
						Validators: []validator.String{
							stringvalidator.LengthAtMost(253),
							stringvalidator.RegexMatches(regexp.MustCompile("^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"), ""),
						},
					},
					"namespace": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: MetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: MetadataValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
			"name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "name of the Interface",
				MarkdownDescription: "name of the Interface",
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"ddm": schema.BoolAttribute{
						Optional:            true,
						Description:         "Enables reporting of DDM events.",
						MarkdownDescription: "Enables reporting of DDM events.",
					},
					"description": schema.StringAttribute{
						Optional:            true,
						Description:         "Description of the interface.",
						MarkdownDescription: "Description of the interface.",
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Enable or disable the interface.",
						MarkdownDescription: "Enable or disable the interface.",
						Default:             booldefault.StaticBool(true),
					},
					"encap_type": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Enable or disable VLAN tagging on this interface. [default=\"null\"]",
						MarkdownDescription: "Enable or disable VLAN tagging on this interface. [default=\"null\"]",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"null",
								"dot1q",
							),
						},
						Default: stringdefault.StaticString("null"),
					},
					"ethernet": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"fec": schema.StringAttribute{
								Optional:            true,
								Description:         "Sets the Forward Error Correction (FEC) on the members of the interface.",
								MarkdownDescription: "Sets the Forward Error Correction (FEC) on the members of the interface.",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"disabled",
										"rs528",
										"rs544",
										"baser",
										"rs108",
									),
								},
							},
							"hold_down_timer": schema.Int64Attribute{
								Optional:            true,
								Description:         "The hold-time down behavior is triggered with events that try to bring the ethernet interface down and can change quickly. It is not triggered with an admin-state disable event or interface disable due to other internal reasons.  Units in milliseconds.",
								MarkdownDescription: "The hold-time down behavior is triggered with events that try to bring the ethernet interface down and can change quickly. It is not triggered with an admin-state disable event or interface disable due to other internal reasons.  Units in milliseconds.",
								Validators: []validator.Int64{
									int64validator.Between(100, 86400000),
								},
							},
							"hold_up_timer": schema.Int64Attribute{
								Optional:            true,
								Description:         "The hold-time up behavior is triggered with any event that tries to bring up the ethernet interface.  While the hold-time up is running, the transceiver laser will be enabled, however the higher layers will not be notified that the interface is operationally up until the timer expires.  Units in milliseconds.",
								MarkdownDescription: "The hold-time up behavior is triggered with any event that tries to bring up the ethernet interface.  While the hold-time up is running, the transceiver laser will be enabled, however the higher layers will not be notified that the interface is operationally up until the timer expires.  Units in milliseconds.",
								Validators: []validator.Int64{
									int64validator.Between(100, 86400000),
								},
							},
							"reload_delay_timer": schema.Int64Attribute{
								Optional:            true,
								Description:         "After the system boots, the reload-delay timer in seconds keeps an interface shut down with the laser off for a configured amount of time until connectivity with the rest of network is established.",
								MarkdownDescription: "After the system boots, the reload-delay timer in seconds keeps an interface shut down with the laser off for a configured amount of time until connectivity with the rest of network is established.",
								Validators: []validator.Int64{
									int64validator.Between(1, 86400),
								},
							},
							"speed": schema.StringAttribute{
								Optional:            true,
								Description:         "The speed of this interface, in human-readable format - e.g. 25G, 100G.",
								MarkdownDescription: "The speed of this interface, in human-readable format - e.g. 25G, 100G.",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"100G",
										"10G",
										"1G",
										"25G",
										"40G",
										"50G",
										"400G",
									),
								},
							},
							"standby_signaling": schema.StringAttribute{
								Optional:            true,
								Description:         "Indicates the standby-signaling used in the interface.",
								MarkdownDescription: "Indicates the standby-signaling used in the interface.",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"lacp",
										"power-off",
									),
								},
							},
							"storm_control": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"broadcast_rate": schema.Int64Attribute{
										Optional:            true,
										Description:         "Sets the maximum rate allowed for ingress broadcast frames on the interface.",
										MarkdownDescription: "Sets the maximum rate allowed for ingress broadcast frames on the interface.",
										Validators: []validator.Int64{
											int64validator.Between(0, 100000000),
										},
									},
									"enabled": schema.BoolAttribute{
										Optional:            true,
										Description:         "Enables storm control.",
										MarkdownDescription: "Enables storm control.",
									},
									"multicast_rate": schema.Int64Attribute{
										Optional:            true,
										Description:         "Sets the maximum rate allowed for ingress multicast frames on the interface.",
										MarkdownDescription: "Sets the maximum rate allowed for ingress multicast frames on the interface.",
										Validators: []validator.Int64{
											int64validator.Between(0, 100000000),
										},
									},
									"units": schema.StringAttribute{
										Optional:            true,
										Description:         "Set the units to be used for measurement.",
										MarkdownDescription: "Set the units to be used for measurement.",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"kbps",
												"percentage",
											),
										},
									},
									"unknown_unicast_rate": schema.Int64Attribute{
										Optional:            true,
										Description:         "Sets the maximum rate allowed for ingress unknown unicast frames on the interface.",
										MarkdownDescription: "Sets the maximum rate allowed for ingress unknown unicast frames on the interface.",
										Validators: []validator.Int64{
											int64validator.Between(0, 100000000),
										},
									},
								},
								CustomType: StormControlType{
									ObjectType: types.ObjectType{
										AttrTypes: StormControlValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "Enables storm control.",
								MarkdownDescription: "Enables storm control.",
							},
							"transparent_l2cpprotocols": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "A list of L2CP protocols to tunnel. Options: LLDP, LACP, xSTP, Dot1x, PTP, All.",
								MarkdownDescription: "A list of L2CP protocols to tunnel. Options: LLDP, LACP, xSTP, Dot1x, PTP, All.",
							},
						},
						CustomType: EthernetType{
							ObjectType: types.ObjectType{
								AttrTypes: EthernetValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Ethernet configuration options.",
						MarkdownDescription: "Ethernet configuration options.",
					},
					"lag": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"lacp": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"admin_key": schema.Int64Attribute{
										Optional:            true,
										Description:         "Configure the LACP admin-key to be advertised by the local system.",
										MarkdownDescription: "Configure the LACP admin-key to be advertised by the local system.",
										Validators: []validator.Int64{
											int64validator.Between(1, 65535),
										},
									},
									"interval": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Set the period between LACP messages, uses the lacp-period-type enumeration. [default=\"fast\"]",
										MarkdownDescription: "Set the period between LACP messages, uses the lacp-period-type enumeration. [default=\"fast\"]",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"fast",
												"slow",
											),
										},
										Default: stringdefault.StaticString("fast"),
									},
									"lacp_fallback": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"mode": schema.StringAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "Specifies lacp-fallback mode if enabled.",
												MarkdownDescription: "Specifies lacp-fallback mode if enabled.",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"static",
													),
												},
												Default: stringdefault.StaticString("static"),
											},
											"timeout": schema.Int64Attribute{
												Optional:            true,
												Computed:            true,
												Description:         "Specifies the LACP-fallback timeout interval in seconds. [default=60]",
												MarkdownDescription: "Specifies the LACP-fallback timeout interval in seconds. [default=60]",
												Validators: []validator.Int64{
													int64validator.Between(4, 3600),
												},
												Default: int64default.StaticInt64(60),
											},
										},
										CustomType: LacpFallbackType{
											ObjectType: types.ObjectType{
												AttrTypes: LacpFallbackValue{}.AttributeTypes(ctx),
											},
										},
										Optional:            true,
										Description:         "LACP fallback allows one or more designated links of an LACP controlled LAG to go into forwarding mode if LACP is not yet operational after a configured timeout period. [default=disabled]",
										MarkdownDescription: "LACP fallback allows one or more designated links of an LACP controlled LAG to go into forwarding mode if LACP is not yet operational after a configured timeout period. [default=disabled]",
									},
									"mode": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Active is to initiate the transmission of LACP PDUs. Passive is to wait for peer to initiate the transmission of LACP PDUs.[default=\"active\"]",
										MarkdownDescription: "Active is to initiate the transmission of LACP PDUs. Passive is to wait for peer to initiate the transmission of LACP PDUs.[default=\"active\"]",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"active",
												"passive",
											),
										},
										Default: stringdefault.StaticString("active"),
									},
									"system_id_mac": schema.StringAttribute{
										Optional:            true,
										Description:         "The MAC address portion of the Node's System ID. This is combined with the system priority to construct the 8-octet system-id.",
										MarkdownDescription: "The MAC address portion of the Node's System ID. This is combined with the system priority to construct the 8-octet system-id.",
									},
									"system_priority": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "System priority used by the Node on this LAG interface. Lower value is higher priority for determining which Node is the controlling system.[default=32768]",
										MarkdownDescription: "System priority used by the Node on this LAG interface. Lower value is higher priority for determining which Node is the controlling system.[default=32768]",
										Validators: []validator.Int64{
											int64validator.Between(0, 65535),
										},
										Default: int64default.StaticInt64(32768),
									},
								},
								CustomType: LacpType{
									ObjectType: types.ObjectType{
										AttrTypes: LacpValue{}.AttributeTypes(ctx),
									},
								},
								Optional: true,
							},
							"min_links": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "The min-link threshold specifies the minimum number of member links that must be active in order for the LAG to be operationally up. If the number of active links falls below this threshold, the entire LAG is brought operationally down.[default=1]",
								MarkdownDescription: "The min-link threshold specifies the minimum number of member links that must be active in order for the LAG to be operationally up. If the number of active links falls below this threshold, the entire LAG is brought operationally down.[default=1]",
								Validators: []validator.Int64{
									int64validator.Between(1, 64),
								},
								Default: int64default.StaticInt64(1),
							},
							"multihoming": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"esi": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "10 byte Ethernet Segment Identifier, if not set a type 0 ESI is generated. [default=auto]",
										MarkdownDescription: "10 byte Ethernet Segment Identifier, if not set a type 0 ESI is generated. [default=auto]",
										Default:             stringdefault.StaticString("auto"),
									},
									"mode": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "\"all-active\": All interfaces are active.\n\"single-active\": In a single active MH LAG, the active and standby function is handled at the sub-interface layer within a network-instance.  That is, the physical interfaces within the same LAG all remain operationally up, however each sub-interface associated with a network-instance has its operational state up or down based on whether it is selected to be the active or standby sub-interface.\n\"port-active\": When port active MH LAG is enabled, the active and standby function is handled at the interface level.",
										MarkdownDescription: "\"all-active\": All interfaces are active.\n\"single-active\": In a single active MH LAG, the active and standby function is handled at the sub-interface layer within a network-instance.  That is, the physical interfaces within the same LAG all remain operationally up, however each sub-interface associated with a network-instance has its operational state up or down based on whether it is selected to be the active or standby sub-interface.\n\"port-active\": When port active MH LAG is enabled, the active and standby function is handled at the interface level.",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"all-active",
												"single-active",
												"port-active",
											),
										},
										Default: stringdefault.StaticString("all-active"),
									},
									"preferred_active_node": schema.StringAttribute{
										Optional:            true,
										Description:         "To be used in single-active or port-active modes.  This references the Node object and when set, the DF algorithm is configured to type preference and the selected Node is set with a higher preference value.  All other Nodes have a lower value configured.",
										MarkdownDescription: "To be used in single-active or port-active modes.  This references the Node object and when set, the DF algorithm is configured to type preference and the selected Node is set with a higher preference value.  All other Nodes have a lower value configured.",
									},
									"reload_delay_timer": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "After the system boots, the reload-delay timer in seconds keeps an interface shut down with the laser off for a configured amount of time until connectivity with the rest of network is established. [default=100]",
										MarkdownDescription: "After the system boots, the reload-delay timer in seconds keeps an interface shut down with the laser off for a configured amount of time until connectivity with the rest of network is established. [default=100]",
										Validators: []validator.Int64{
											int64validator.Between(1, 86400),
										},
										Default: int64default.StaticInt64(100),
									},
									"revertive": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "To be used in single-active or port-active modes.  When true, if there is a switch of active interface in the LAG and the original interface comes back up, the LAG will switch back to using the original interface as active. [default=false]",
										MarkdownDescription: "To be used in single-active or port-active modes.  When true, if there is a switch of active interface in the LAG and the original interface comes back up, the LAG will switch back to using the original interface as active. [default=false]",
										Default:             booldefault.StaticBool(false),
									},
								},
								CustomType: MultihomingType{
									ObjectType: types.ObjectType{
										AttrTypes: MultihomingValue{}.AttributeTypes(ctx),
									},
								},
								Optional: true,
							},
							"type": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "This type defines whether whether it is a static or LACP LAG. [default=lacp]",
								MarkdownDescription: "This type defines whether whether it is a static or LACP LAG. [default=lacp]",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"lacp",
										"static",
									),
								},
								Default: stringdefault.StaticString("lacp"),
							},
						},
						CustomType: LagType{
							ObjectType: types.ObjectType{
								AttrTypes: LagValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "LAG configuration options.",
						MarkdownDescription: "LAG configuration options.",
					},
					"lldp": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Enable or disable LLDP on the members of the interface.",
						MarkdownDescription: "Enable or disable LLDP on the members of the interface.",
						Default:             booldefault.StaticBool(true),
					},
					"members": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"aggregate_id": schema.StringAttribute{
									Optional:            true,
									Description:         "When using a LAG, the aggregateId can be specified per set of interfaces on a node.\nLAG interface with which this interface is associated.",
									MarkdownDescription: "When using a LAG, the aggregateId can be specified per set of interfaces on a node.\nLAG interface with which this interface is associated.",
								},
								"description": schema.StringAttribute{
									Optional:            true,
									Description:         "Description of the member, inherited from the interface if not provided.",
									MarkdownDescription: "Description of the member, inherited from the interface if not provided.",
								},
								"enabled": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Enable or disable this member.",
									MarkdownDescription: "Enable or disable this member.",
									Default:             booldefault.StaticBool(true),
								},
								"interface": schema.StringAttribute{
									Required:            true,
									Description:         "Reference to an interface in the normalized format. Ex: SRL ethernet-1/1 would be ethernet-1-1. SROS port 2/1/1 would be ethernet-2-1.",
									MarkdownDescription: "Reference to an interface in the normalized format. Ex: SRL ethernet-1/1 would be ethernet-1-1. SROS port 2/1/1 would be ethernet-2-1.",
								},
								"lacp_port_priority": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "Configure the port priority for LACP. This value is used to determine which port should be activated with LACP fallback mode. Lower values are more preferred.[default=32768]",
									MarkdownDescription: "Configure the port priority for LACP. This value is used to determine which port should be activated with LACP fallback mode. Lower values are more preferred.[default=32768]",
									Validators: []validator.Int64{
										int64validator.Between(0, 65535),
									},
									Default: int64default.StaticInt64(32768),
								},
								"node": schema.StringAttribute{
									Required:            true,
									Description:         "Node name.",
									MarkdownDescription: "Node name.",
								},
							},
							CustomType: MembersType{
								ObjectType: types.ObjectType{
									AttrTypes: MembersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Required:            true,
						Description:         "List of members on which to apply properties, for single interface this would be a list of 1.",
						MarkdownDescription: "List of members on which to apply properties, for single interface this would be a list of 1.",
					},
					"mtu": schema.Int64Attribute{
						Optional:            true,
						Description:         "MTU to apply on the interface(s).",
						MarkdownDescription: "MTU to apply on the interface(s).",
						Validators: []validator.Int64{
							int64validator.Between(1450, 9500),
						},
					},
					"type": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Type defines whether the interface is a Lag or Interface.",
						MarkdownDescription: "Type defines whether the interface is a Lag or Interface.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"lag",
								"interface",
								"loopback",
							),
						},
						Default: stringdefault.StaticString("interface"),
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "Interface allows for the configuration of various interface properties such as enabling/disabling the interface, setting descriptions, specifying interface types (e.g., LAG, interface, loopback), configuring VLAN encapsulation, and setting Ethernet or LAG-specific options.",
				MarkdownDescription: "Interface allows for the configuration of various interface properties such as enabling/disabling the interface, setting descriptions, specifying interface types (e.g., LAG, interface, loopback), configuring VLAN encapsulation, and setting Ethernet or LAG-specific options.",
			},
			"status": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The administrative status of the Interface.",
						MarkdownDescription: "The administrative status of the Interface.",
					},
					"lag_1": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"admin_key": schema.Int64Attribute{
								Optional: true,
								Computed: true,
							},
							"system_id_mac": schema.StringAttribute{
								Optional: true,
								Computed: true,
							},
						},
						CustomType: Lag1Type{
							ObjectType: types.ObjectType{
								AttrTypes: Lag1Value{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
						Computed: true,
					},
					"last_change": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Indicates when this Interface last changed state.",
						MarkdownDescription: "Indicates when this Interface last changed state.",
					},
					"members_1": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The administrative status of this member.",
									MarkdownDescription: "The administrative status of this member.",
								},
								"interface": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The name of the interface in normalized format.",
									MarkdownDescription: "The name of the interface in normalized format.",
								},
								"last_change": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Indicates when this member last changed state.",
									MarkdownDescription: "Indicates when this member last changed state.",
								},
								"neighbors": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"interface": schema.StringAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "The name of a neighbor interface of this member in node specific format.",
												MarkdownDescription: "The name of a neighbor interface of this member in node specific format.",
											},
											"node": schema.StringAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "The name of a neighbor node of this member in node specific format.",
												MarkdownDescription: "The name of a neighbor node of this member in node specific format.",
											},
										},
										CustomType: NeighborsType{
											ObjectType: types.ObjectType{
												AttrTypes: NeighborsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Computed:            true,
									Description:         "List of discovered neighbors on this member.",
									MarkdownDescription: "List of discovered neighbors on this member.",
								},
								"node": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The node on which the interface is configured.",
									MarkdownDescription: "The node on which the interface is configured.",
								},
								"node_interface": schema.StringAttribute{
									Required:            true,
									Description:         "Node specific interface name, for example \"ethernet-1/1\", \"1/1/c1/1\".",
									MarkdownDescription: "Node specific interface name, for example \"ethernet-1/1\", \"1/1/c1/1\".",
								},
								"operational_state": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Indicates the current operational state of this member.",
									MarkdownDescription: "Indicates the current operational state of this member.",
								},
								"speed": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Indicates the operational speed of the member.",
									MarkdownDescription: "Indicates the operational speed of the member.",
								},
							},
							CustomType: Members1Type{
								ObjectType: types.ObjectType{
									AttrTypes: Members1Value{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "List of members in this Interface.",
						MarkdownDescription: "List of members in this Interface.",
					},
					"operational_state": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Indicates the current operational state of the Interface.",
						MarkdownDescription: "Indicates the current operational state of the Interface.",
					},
					"speed": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Indicates the operational speed of the Interface in aggregate.",
						MarkdownDescription: "Indicates the operational speed of the Interface in aggregate.",
					},
				},
				CustomType: StatusType{
					ObjectType: types.ObjectType{
						AttrTypes: StatusValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
		},
	}
}

type InterfaceModel struct {
	ApiVersion types.String  `tfsdk:"api_version"`
	Kind       types.String  `tfsdk:"kind"`
	Metadata   MetadataValue `tfsdk:"metadata"`
	Name       types.String  `tfsdk:"name"`
	Namespace  types.String  `tfsdk:"namespace"`
	Spec       SpecValue     `tfsdk:"spec"`
	Status     StatusValue   `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ddmAttribute, ok := attributes["ddm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ddm is missing from object`)

		return nil, diags
	}

	ddmVal, ok := ddmAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ddm expected to be basetypes.BoolValue, was: %T`, ddmAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	encapTypeAttribute, ok := attributes["encap_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`encap_type is missing from object`)

		return nil, diags
	}

	encapTypeVal, ok := encapTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`encap_type expected to be basetypes.StringValue, was: %T`, encapTypeAttribute))
	}

	ethernetAttribute, ok := attributes["ethernet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ethernet is missing from object`)

		return nil, diags
	}

	ethernetVal, ok := ethernetAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ethernet expected to be basetypes.ObjectValue, was: %T`, ethernetAttribute))
	}

	lagAttribute, ok := attributes["lag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lag is missing from object`)

		return nil, diags
	}

	lagVal, ok := lagAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lag expected to be basetypes.ObjectValue, was: %T`, lagAttribute))
	}

	lldpAttribute, ok := attributes["lldp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lldp is missing from object`)

		return nil, diags
	}

	lldpVal, ok := lldpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lldp expected to be basetypes.BoolValue, was: %T`, lldpAttribute))
	}

	membersAttribute, ok := attributes["members"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`members is missing from object`)

		return nil, diags
	}

	membersVal, ok := membersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`members expected to be basetypes.ListValue, was: %T`, membersAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return nil, diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		Ddm:         ddmVal,
		Description: descriptionVal,
		Enabled:     enabledVal,
		EncapType:   encapTypeVal,
		Ethernet:    ethernetVal,
		Lag:         lagVal,
		Lldp:        lldpVal,
		Members:     membersVal,
		Mtu:         mtuVal,
		SpecType:    typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	ddmAttribute, ok := attributes["ddm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ddm is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	ddmVal, ok := ddmAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ddm expected to be basetypes.BoolValue, was: %T`, ddmAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	encapTypeAttribute, ok := attributes["encap_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`encap_type is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	encapTypeVal, ok := encapTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`encap_type expected to be basetypes.StringValue, was: %T`, encapTypeAttribute))
	}

	ethernetAttribute, ok := attributes["ethernet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ethernet is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	ethernetVal, ok := ethernetAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ethernet expected to be basetypes.ObjectValue, was: %T`, ethernetAttribute))
	}

	lagAttribute, ok := attributes["lag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lag is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	lagVal, ok := lagAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lag expected to be basetypes.ObjectValue, was: %T`, lagAttribute))
	}

	lldpAttribute, ok := attributes["lldp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lldp is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	lldpVal, ok := lldpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lldp expected to be basetypes.BoolValue, was: %T`, lldpAttribute))
	}

	membersAttribute, ok := attributes["members"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`members is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	membersVal, ok := membersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`members expected to be basetypes.ListValue, was: %T`, membersAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		Ddm:         ddmVal,
		Description: descriptionVal,
		Enabled:     enabledVal,
		EncapType:   encapTypeVal,
		Ethernet:    ethernetVal,
		Lag:         lagVal,
		Lldp:        lldpVal,
		Members:     membersVal,
		Mtu:         mtuVal,
		SpecType:    typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	Ddm         basetypes.BoolValue   `tfsdk:"ddm"`
	Description basetypes.StringValue `tfsdk:"description"`
	Enabled     basetypes.BoolValue   `tfsdk:"enabled"`
	EncapType   basetypes.StringValue `tfsdk:"encap_type"`
	Ethernet    basetypes.ObjectValue `tfsdk:"ethernet"`
	Lag         basetypes.ObjectValue `tfsdk:"lag"`
	Lldp        basetypes.BoolValue   `tfsdk:"lldp"`
	Members     basetypes.ListValue   `tfsdk:"members"`
	Mtu         basetypes.Int64Value  `tfsdk:"mtu"`
	SpecType    basetypes.StringValue `tfsdk:"type"`
	state       attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["ddm"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["encap_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ethernet"] = basetypes.ObjectType{
		AttrTypes: EthernetValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["lag"] = basetypes.ObjectType{
		AttrTypes: LagValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["lldp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["members"] = basetypes.ListType{
		ElemType: MembersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Ddm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ddm"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.EncapType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["encap_type"] = val

		val, err = v.Ethernet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ethernet"] = val

		val, err = v.Lag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lag"] = val

		val, err = v.Lldp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lldp"] = val

		val, err = v.Members.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["members"] = val

		val, err = v.Mtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mtu"] = val

		val, err = v.SpecType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var ethernet basetypes.ObjectValue

	if v.Ethernet.IsNull() {
		ethernet = types.ObjectNull(
			EthernetValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ethernet.IsUnknown() {
		ethernet = types.ObjectUnknown(
			EthernetValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ethernet.IsNull() && !v.Ethernet.IsUnknown() {
		ethernet = types.ObjectValueMust(
			EthernetValue{}.AttributeTypes(ctx),
			v.Ethernet.Attributes(),
		)
	}

	var lag basetypes.ObjectValue

	if v.Lag.IsNull() {
		lag = types.ObjectNull(
			LagValue{}.AttributeTypes(ctx),
		)
	}

	if v.Lag.IsUnknown() {
		lag = types.ObjectUnknown(
			LagValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Lag.IsNull() && !v.Lag.IsUnknown() {
		lag = types.ObjectValueMust(
			LagValue{}.AttributeTypes(ctx),
			v.Lag.Attributes(),
		)
	}

	members := types.ListValueMust(
		MembersType{
			basetypes.ObjectType{
				AttrTypes: MembersValue{}.AttributeTypes(ctx),
			},
		},
		v.Members.Elements(),
	)

	if v.Members.IsNull() {
		members = types.ListNull(
			MembersType{
				basetypes.ObjectType{
					AttrTypes: MembersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Members.IsUnknown() {
		members = types.ListUnknown(
			MembersType{
				basetypes.ObjectType{
					AttrTypes: MembersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"ddm":         basetypes.BoolType{},
		"description": basetypes.StringType{},
		"enabled":     basetypes.BoolType{},
		"encap_type":  basetypes.StringType{},
		"ethernet": basetypes.ObjectType{
			AttrTypes: EthernetValue{}.AttributeTypes(ctx),
		},
		"lag": basetypes.ObjectType{
			AttrTypes: LagValue{}.AttributeTypes(ctx),
		},
		"lldp": basetypes.BoolType{},
		"members": basetypes.ListType{
			ElemType: MembersValue{}.Type(ctx),
		},
		"mtu":  basetypes.Int64Type{},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ddm":         v.Ddm,
			"description": v.Description,
			"enabled":     v.Enabled,
			"encap_type":  v.EncapType,
			"ethernet":    ethernet,
			"lag":         lag,
			"lldp":        v.Lldp,
			"members":     members,
			"mtu":         v.Mtu,
			"type":        v.SpecType,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ddm.Equal(other.Ddm) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.EncapType.Equal(other.EncapType) {
		return false
	}

	if !v.Ethernet.Equal(other.Ethernet) {
		return false
	}

	if !v.Lag.Equal(other.Lag) {
		return false
	}

	if !v.Lldp.Equal(other.Lldp) {
		return false
	}

	if !v.Members.Equal(other.Members) {
		return false
	}

	if !v.Mtu.Equal(other.Mtu) {
		return false
	}

	if !v.SpecType.Equal(other.SpecType) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ddm":         basetypes.BoolType{},
		"description": basetypes.StringType{},
		"enabled":     basetypes.BoolType{},
		"encap_type":  basetypes.StringType{},
		"ethernet": basetypes.ObjectType{
			AttrTypes: EthernetValue{}.AttributeTypes(ctx),
		},
		"lag": basetypes.ObjectType{
			AttrTypes: LagValue{}.AttributeTypes(ctx),
		},
		"lldp": basetypes.BoolType{},
		"members": basetypes.ListType{
			ElemType: MembersValue{}.Type(ctx),
		},
		"mtu":  basetypes.Int64Type{},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = EthernetType{}

type EthernetType struct {
	basetypes.ObjectType
}

func (t EthernetType) Equal(o attr.Type) bool {
	other, ok := o.(EthernetType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EthernetType) String() string {
	return "EthernetType"
}

func (t EthernetType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	fecAttribute, ok := attributes["fec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fec is missing from object`)

		return nil, diags
	}

	fecVal, ok := fecAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fec expected to be basetypes.StringValue, was: %T`, fecAttribute))
	}

	holdDownTimerAttribute, ok := attributes["hold_down_timer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_down_timer is missing from object`)

		return nil, diags
	}

	holdDownTimerVal, ok := holdDownTimerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_down_timer expected to be basetypes.Int64Value, was: %T`, holdDownTimerAttribute))
	}

	holdUpTimerAttribute, ok := attributes["hold_up_timer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_up_timer is missing from object`)

		return nil, diags
	}

	holdUpTimerVal, ok := holdUpTimerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_up_timer expected to be basetypes.Int64Value, was: %T`, holdUpTimerAttribute))
	}

	reloadDelayTimerAttribute, ok := attributes["reload_delay_timer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reload_delay_timer is missing from object`)

		return nil, diags
	}

	reloadDelayTimerVal, ok := reloadDelayTimerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reload_delay_timer expected to be basetypes.Int64Value, was: %T`, reloadDelayTimerAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return nil, diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	standbySignalingAttribute, ok := attributes["standby_signaling"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`standby_signaling is missing from object`)

		return nil, diags
	}

	standbySignalingVal, ok := standbySignalingAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`standby_signaling expected to be basetypes.StringValue, was: %T`, standbySignalingAttribute))
	}

	stormControlAttribute, ok := attributes["storm_control"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storm_control is missing from object`)

		return nil, diags
	}

	stormControlVal, ok := stormControlAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storm_control expected to be basetypes.ObjectValue, was: %T`, stormControlAttribute))
	}

	transparentL2cpprotocolsAttribute, ok := attributes["transparent_l2cpprotocols"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transparent_l2cpprotocols is missing from object`)

		return nil, diags
	}

	transparentL2cpprotocolsVal, ok := transparentL2cpprotocolsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transparent_l2cpprotocols expected to be basetypes.ListValue, was: %T`, transparentL2cpprotocolsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EthernetValue{
		Fec:                      fecVal,
		HoldDownTimer:            holdDownTimerVal,
		HoldUpTimer:              holdUpTimerVal,
		ReloadDelayTimer:         reloadDelayTimerVal,
		Speed:                    speedVal,
		StandbySignaling:         standbySignalingVal,
		StormControl:             stormControlVal,
		TransparentL2cpprotocols: transparentL2cpprotocolsVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewEthernetValueNull() EthernetValue {
	return EthernetValue{
		state: attr.ValueStateNull,
	}
}

func NewEthernetValueUnknown() EthernetValue {
	return EthernetValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEthernetValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EthernetValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EthernetValue Attribute Value",
				"While creating a EthernetValue value, a missing attribute value was detected. "+
					"A EthernetValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EthernetValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EthernetValue Attribute Type",
				"While creating a EthernetValue value, an invalid attribute value was detected. "+
					"A EthernetValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EthernetValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EthernetValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EthernetValue Attribute Value",
				"While creating a EthernetValue value, an extra attribute value was detected. "+
					"A EthernetValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EthernetValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEthernetValueUnknown(), diags
	}

	fecAttribute, ok := attributes["fec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fec is missing from object`)

		return NewEthernetValueUnknown(), diags
	}

	fecVal, ok := fecAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fec expected to be basetypes.StringValue, was: %T`, fecAttribute))
	}

	holdDownTimerAttribute, ok := attributes["hold_down_timer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_down_timer is missing from object`)

		return NewEthernetValueUnknown(), diags
	}

	holdDownTimerVal, ok := holdDownTimerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_down_timer expected to be basetypes.Int64Value, was: %T`, holdDownTimerAttribute))
	}

	holdUpTimerAttribute, ok := attributes["hold_up_timer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_up_timer is missing from object`)

		return NewEthernetValueUnknown(), diags
	}

	holdUpTimerVal, ok := holdUpTimerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_up_timer expected to be basetypes.Int64Value, was: %T`, holdUpTimerAttribute))
	}

	reloadDelayTimerAttribute, ok := attributes["reload_delay_timer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reload_delay_timer is missing from object`)

		return NewEthernetValueUnknown(), diags
	}

	reloadDelayTimerVal, ok := reloadDelayTimerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reload_delay_timer expected to be basetypes.Int64Value, was: %T`, reloadDelayTimerAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return NewEthernetValueUnknown(), diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	standbySignalingAttribute, ok := attributes["standby_signaling"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`standby_signaling is missing from object`)

		return NewEthernetValueUnknown(), diags
	}

	standbySignalingVal, ok := standbySignalingAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`standby_signaling expected to be basetypes.StringValue, was: %T`, standbySignalingAttribute))
	}

	stormControlAttribute, ok := attributes["storm_control"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storm_control is missing from object`)

		return NewEthernetValueUnknown(), diags
	}

	stormControlVal, ok := stormControlAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storm_control expected to be basetypes.ObjectValue, was: %T`, stormControlAttribute))
	}

	transparentL2cpprotocolsAttribute, ok := attributes["transparent_l2cpprotocols"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transparent_l2cpprotocols is missing from object`)

		return NewEthernetValueUnknown(), diags
	}

	transparentL2cpprotocolsVal, ok := transparentL2cpprotocolsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transparent_l2cpprotocols expected to be basetypes.ListValue, was: %T`, transparentL2cpprotocolsAttribute))
	}

	if diags.HasError() {
		return NewEthernetValueUnknown(), diags
	}

	return EthernetValue{
		Fec:                      fecVal,
		HoldDownTimer:            holdDownTimerVal,
		HoldUpTimer:              holdUpTimerVal,
		ReloadDelayTimer:         reloadDelayTimerVal,
		Speed:                    speedVal,
		StandbySignaling:         standbySignalingVal,
		StormControl:             stormControlVal,
		TransparentL2cpprotocols: transparentL2cpprotocolsVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewEthernetValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EthernetValue {
	object, diags := NewEthernetValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEthernetValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EthernetType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEthernetValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEthernetValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEthernetValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEthernetValueMust(EthernetValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EthernetType) ValueType(ctx context.Context) attr.Value {
	return EthernetValue{}
}

var _ basetypes.ObjectValuable = EthernetValue{}

type EthernetValue struct {
	Fec                      basetypes.StringValue `tfsdk:"fec"`
	HoldDownTimer            basetypes.Int64Value  `tfsdk:"hold_down_timer"`
	HoldUpTimer              basetypes.Int64Value  `tfsdk:"hold_up_timer"`
	ReloadDelayTimer         basetypes.Int64Value  `tfsdk:"reload_delay_timer"`
	Speed                    basetypes.StringValue `tfsdk:"speed"`
	StandbySignaling         basetypes.StringValue `tfsdk:"standby_signaling"`
	StormControl             basetypes.ObjectValue `tfsdk:"storm_control"`
	TransparentL2cpprotocols basetypes.ListValue   `tfsdk:"transparent_l2cpprotocols"`
	state                    attr.ValueState
}

func (v EthernetValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["fec"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["hold_down_timer"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["hold_up_timer"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["reload_delay_timer"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["speed"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["standby_signaling"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["storm_control"] = basetypes.ObjectType{
		AttrTypes: StormControlValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["transparent_l2cpprotocols"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Fec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fec"] = val

		val, err = v.HoldDownTimer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hold_down_timer"] = val

		val, err = v.HoldUpTimer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hold_up_timer"] = val

		val, err = v.ReloadDelayTimer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reload_delay_timer"] = val

		val, err = v.Speed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["speed"] = val

		val, err = v.StandbySignaling.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["standby_signaling"] = val

		val, err = v.StormControl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storm_control"] = val

		val, err = v.TransparentL2cpprotocols.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["transparent_l2cpprotocols"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EthernetValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EthernetValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EthernetValue) String() string {
	return "EthernetValue"
}

func (v EthernetValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var stormControl basetypes.ObjectValue

	if v.StormControl.IsNull() {
		stormControl = types.ObjectNull(
			StormControlValue{}.AttributeTypes(ctx),
		)
	}

	if v.StormControl.IsUnknown() {
		stormControl = types.ObjectUnknown(
			StormControlValue{}.AttributeTypes(ctx),
		)
	}

	if !v.StormControl.IsNull() && !v.StormControl.IsUnknown() {
		stormControl = types.ObjectValueMust(
			StormControlValue{}.AttributeTypes(ctx),
			v.StormControl.Attributes(),
		)
	}

	var transparentL2cpprotocolsVal basetypes.ListValue
	switch {
	case v.TransparentL2cpprotocols.IsUnknown():
		transparentL2cpprotocolsVal = types.ListUnknown(types.StringType)
	case v.TransparentL2cpprotocols.IsNull():
		transparentL2cpprotocolsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		transparentL2cpprotocolsVal, d = types.ListValue(types.StringType, v.TransparentL2cpprotocols.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"fec":                basetypes.StringType{},
			"hold_down_timer":    basetypes.Int64Type{},
			"hold_up_timer":      basetypes.Int64Type{},
			"reload_delay_timer": basetypes.Int64Type{},
			"speed":              basetypes.StringType{},
			"standby_signaling":  basetypes.StringType{},
			"storm_control": basetypes.ObjectType{
				AttrTypes: StormControlValue{}.AttributeTypes(ctx),
			},
			"transparent_l2cpprotocols": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"fec":                basetypes.StringType{},
		"hold_down_timer":    basetypes.Int64Type{},
		"hold_up_timer":      basetypes.Int64Type{},
		"reload_delay_timer": basetypes.Int64Type{},
		"speed":              basetypes.StringType{},
		"standby_signaling":  basetypes.StringType{},
		"storm_control": basetypes.ObjectType{
			AttrTypes: StormControlValue{}.AttributeTypes(ctx),
		},
		"transparent_l2cpprotocols": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"fec":                       v.Fec,
			"hold_down_timer":           v.HoldDownTimer,
			"hold_up_timer":             v.HoldUpTimer,
			"reload_delay_timer":        v.ReloadDelayTimer,
			"speed":                     v.Speed,
			"standby_signaling":         v.StandbySignaling,
			"storm_control":             stormControl,
			"transparent_l2cpprotocols": transparentL2cpprotocolsVal,
		})

	return objVal, diags
}

func (v EthernetValue) Equal(o attr.Value) bool {
	other, ok := o.(EthernetValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Fec.Equal(other.Fec) {
		return false
	}

	if !v.HoldDownTimer.Equal(other.HoldDownTimer) {
		return false
	}

	if !v.HoldUpTimer.Equal(other.HoldUpTimer) {
		return false
	}

	if !v.ReloadDelayTimer.Equal(other.ReloadDelayTimer) {
		return false
	}

	if !v.Speed.Equal(other.Speed) {
		return false
	}

	if !v.StandbySignaling.Equal(other.StandbySignaling) {
		return false
	}

	if !v.StormControl.Equal(other.StormControl) {
		return false
	}

	if !v.TransparentL2cpprotocols.Equal(other.TransparentL2cpprotocols) {
		return false
	}

	return true
}

func (v EthernetValue) Type(ctx context.Context) attr.Type {
	return EthernetType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EthernetValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"fec":                basetypes.StringType{},
		"hold_down_timer":    basetypes.Int64Type{},
		"hold_up_timer":      basetypes.Int64Type{},
		"reload_delay_timer": basetypes.Int64Type{},
		"speed":              basetypes.StringType{},
		"standby_signaling":  basetypes.StringType{},
		"storm_control": basetypes.ObjectType{
			AttrTypes: StormControlValue{}.AttributeTypes(ctx),
		},
		"transparent_l2cpprotocols": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = StormControlType{}

type StormControlType struct {
	basetypes.ObjectType
}

func (t StormControlType) Equal(o attr.Type) bool {
	other, ok := o.(StormControlType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StormControlType) String() string {
	return "StormControlType"
}

func (t StormControlType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	broadcastRateAttribute, ok := attributes["broadcast_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`broadcast_rate is missing from object`)

		return nil, diags
	}

	broadcastRateVal, ok := broadcastRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`broadcast_rate expected to be basetypes.Int64Value, was: %T`, broadcastRateAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	multicastRateAttribute, ok := attributes["multicast_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multicast_rate is missing from object`)

		return nil, diags
	}

	multicastRateVal, ok := multicastRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multicast_rate expected to be basetypes.Int64Value, was: %T`, multicastRateAttribute))
	}

	unitsAttribute, ok := attributes["units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units is missing from object`)

		return nil, diags
	}

	unitsVal, ok := unitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units expected to be basetypes.StringValue, was: %T`, unitsAttribute))
	}

	unknownUnicastRateAttribute, ok := attributes["unknown_unicast_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unknown_unicast_rate is missing from object`)

		return nil, diags
	}

	unknownUnicastRateVal, ok := unknownUnicastRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unknown_unicast_rate expected to be basetypes.Int64Value, was: %T`, unknownUnicastRateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StormControlValue{
		BroadcastRate:      broadcastRateVal,
		Enabled:            enabledVal,
		MulticastRate:      multicastRateVal,
		Units:              unitsVal,
		UnknownUnicastRate: unknownUnicastRateVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewStormControlValueNull() StormControlValue {
	return StormControlValue{
		state: attr.ValueStateNull,
	}
}

func NewStormControlValueUnknown() StormControlValue {
	return StormControlValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStormControlValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StormControlValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StormControlValue Attribute Value",
				"While creating a StormControlValue value, a missing attribute value was detected. "+
					"A StormControlValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StormControlValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StormControlValue Attribute Type",
				"While creating a StormControlValue value, an invalid attribute value was detected. "+
					"A StormControlValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StormControlValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StormControlValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StormControlValue Attribute Value",
				"While creating a StormControlValue value, an extra attribute value was detected. "+
					"A StormControlValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StormControlValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStormControlValueUnknown(), diags
	}

	broadcastRateAttribute, ok := attributes["broadcast_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`broadcast_rate is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	broadcastRateVal, ok := broadcastRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`broadcast_rate expected to be basetypes.Int64Value, was: %T`, broadcastRateAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	multicastRateAttribute, ok := attributes["multicast_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multicast_rate is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	multicastRateVal, ok := multicastRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multicast_rate expected to be basetypes.Int64Value, was: %T`, multicastRateAttribute))
	}

	unitsAttribute, ok := attributes["units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	unitsVal, ok := unitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units expected to be basetypes.StringValue, was: %T`, unitsAttribute))
	}

	unknownUnicastRateAttribute, ok := attributes["unknown_unicast_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unknown_unicast_rate is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	unknownUnicastRateVal, ok := unknownUnicastRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unknown_unicast_rate expected to be basetypes.Int64Value, was: %T`, unknownUnicastRateAttribute))
	}

	if diags.HasError() {
		return NewStormControlValueUnknown(), diags
	}

	return StormControlValue{
		BroadcastRate:      broadcastRateVal,
		Enabled:            enabledVal,
		MulticastRate:      multicastRateVal,
		Units:              unitsVal,
		UnknownUnicastRate: unknownUnicastRateVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewStormControlValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StormControlValue {
	object, diags := NewStormControlValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStormControlValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StormControlType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStormControlValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStormControlValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStormControlValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStormControlValueMust(StormControlValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StormControlType) ValueType(ctx context.Context) attr.Value {
	return StormControlValue{}
}

var _ basetypes.ObjectValuable = StormControlValue{}

type StormControlValue struct {
	BroadcastRate      basetypes.Int64Value  `tfsdk:"broadcast_rate"`
	Enabled            basetypes.BoolValue   `tfsdk:"enabled"`
	MulticastRate      basetypes.Int64Value  `tfsdk:"multicast_rate"`
	Units              basetypes.StringValue `tfsdk:"units"`
	UnknownUnicastRate basetypes.Int64Value  `tfsdk:"unknown_unicast_rate"`
	state              attr.ValueState
}

func (v StormControlValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["broadcast_rate"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["multicast_rate"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["units"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["unknown_unicast_rate"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.BroadcastRate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["broadcast_rate"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.MulticastRate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["multicast_rate"] = val

		val, err = v.Units.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["units"] = val

		val, err = v.UnknownUnicastRate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unknown_unicast_rate"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StormControlValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StormControlValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StormControlValue) String() string {
	return "StormControlValue"
}

func (v StormControlValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"broadcast_rate":       basetypes.Int64Type{},
		"enabled":              basetypes.BoolType{},
		"multicast_rate":       basetypes.Int64Type{},
		"units":                basetypes.StringType{},
		"unknown_unicast_rate": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"broadcast_rate":       v.BroadcastRate,
			"enabled":              v.Enabled,
			"multicast_rate":       v.MulticastRate,
			"units":                v.Units,
			"unknown_unicast_rate": v.UnknownUnicastRate,
		})

	return objVal, diags
}

func (v StormControlValue) Equal(o attr.Value) bool {
	other, ok := o.(StormControlValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BroadcastRate.Equal(other.BroadcastRate) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.MulticastRate.Equal(other.MulticastRate) {
		return false
	}

	if !v.Units.Equal(other.Units) {
		return false
	}

	if !v.UnknownUnicastRate.Equal(other.UnknownUnicastRate) {
		return false
	}

	return true
}

func (v StormControlValue) Type(ctx context.Context) attr.Type {
	return StormControlType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StormControlValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"broadcast_rate":       basetypes.Int64Type{},
		"enabled":              basetypes.BoolType{},
		"multicast_rate":       basetypes.Int64Type{},
		"units":                basetypes.StringType{},
		"unknown_unicast_rate": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = LagType{}

type LagType struct {
	basetypes.ObjectType
}

func (t LagType) Equal(o attr.Type) bool {
	other, ok := o.(LagType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LagType) String() string {
	return "LagType"
}

func (t LagType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	lacpAttribute, ok := attributes["lacp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lacp is missing from object`)

		return nil, diags
	}

	lacpVal, ok := lacpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lacp expected to be basetypes.ObjectValue, was: %T`, lacpAttribute))
	}

	minLinksAttribute, ok := attributes["min_links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_links is missing from object`)

		return nil, diags
	}

	minLinksVal, ok := minLinksAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_links expected to be basetypes.Int64Value, was: %T`, minLinksAttribute))
	}

	multihomingAttribute, ok := attributes["multihoming"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multihoming is missing from object`)

		return nil, diags
	}

	multihomingVal, ok := multihomingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multihoming expected to be basetypes.ObjectValue, was: %T`, multihomingAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LagValue{
		Lacp:        lacpVal,
		MinLinks:    minLinksVal,
		Multihoming: multihomingVal,
		LagType:     typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewLagValueNull() LagValue {
	return LagValue{
		state: attr.ValueStateNull,
	}
}

func NewLagValueUnknown() LagValue {
	return LagValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLagValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LagValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LagValue Attribute Value",
				"While creating a LagValue value, a missing attribute value was detected. "+
					"A LagValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LagValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LagValue Attribute Type",
				"While creating a LagValue value, an invalid attribute value was detected. "+
					"A LagValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LagValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LagValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LagValue Attribute Value",
				"While creating a LagValue value, an extra attribute value was detected. "+
					"A LagValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LagValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLagValueUnknown(), diags
	}

	lacpAttribute, ok := attributes["lacp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lacp is missing from object`)

		return NewLagValueUnknown(), diags
	}

	lacpVal, ok := lacpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lacp expected to be basetypes.ObjectValue, was: %T`, lacpAttribute))
	}

	minLinksAttribute, ok := attributes["min_links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_links is missing from object`)

		return NewLagValueUnknown(), diags
	}

	minLinksVal, ok := minLinksAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_links expected to be basetypes.Int64Value, was: %T`, minLinksAttribute))
	}

	multihomingAttribute, ok := attributes["multihoming"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multihoming is missing from object`)

		return NewLagValueUnknown(), diags
	}

	multihomingVal, ok := multihomingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multihoming expected to be basetypes.ObjectValue, was: %T`, multihomingAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewLagValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewLagValueUnknown(), diags
	}

	return LagValue{
		Lacp:        lacpVal,
		MinLinks:    minLinksVal,
		Multihoming: multihomingVal,
		LagType:     typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewLagValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LagValue {
	object, diags := NewLagValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLagValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LagType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLagValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLagValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLagValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLagValueMust(LagValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LagType) ValueType(ctx context.Context) attr.Value {
	return LagValue{}
}

var _ basetypes.ObjectValuable = LagValue{}

type LagValue struct {
	Lacp        basetypes.ObjectValue `tfsdk:"lacp"`
	MinLinks    basetypes.Int64Value  `tfsdk:"min_links"`
	Multihoming basetypes.ObjectValue `tfsdk:"multihoming"`
	LagType     basetypes.StringValue `tfsdk:"type"`
	state       attr.ValueState
}

func (v LagValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["lacp"] = basetypes.ObjectType{
		AttrTypes: LacpValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["min_links"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["multihoming"] = basetypes.ObjectType{
		AttrTypes: MultihomingValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Lacp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lacp"] = val

		val, err = v.MinLinks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_links"] = val

		val, err = v.Multihoming.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["multihoming"] = val

		val, err = v.LagType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LagValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LagValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LagValue) String() string {
	return "LagValue"
}

func (v LagValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var lacp basetypes.ObjectValue

	if v.Lacp.IsNull() {
		lacp = types.ObjectNull(
			LacpValue{}.AttributeTypes(ctx),
		)
	}

	if v.Lacp.IsUnknown() {
		lacp = types.ObjectUnknown(
			LacpValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Lacp.IsNull() && !v.Lacp.IsUnknown() {
		lacp = types.ObjectValueMust(
			LacpValue{}.AttributeTypes(ctx),
			v.Lacp.Attributes(),
		)
	}

	var multihoming basetypes.ObjectValue

	if v.Multihoming.IsNull() {
		multihoming = types.ObjectNull(
			MultihomingValue{}.AttributeTypes(ctx),
		)
	}

	if v.Multihoming.IsUnknown() {
		multihoming = types.ObjectUnknown(
			MultihomingValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Multihoming.IsNull() && !v.Multihoming.IsUnknown() {
		multihoming = types.ObjectValueMust(
			MultihomingValue{}.AttributeTypes(ctx),
			v.Multihoming.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"lacp": basetypes.ObjectType{
			AttrTypes: LacpValue{}.AttributeTypes(ctx),
		},
		"min_links": basetypes.Int64Type{},
		"multihoming": basetypes.ObjectType{
			AttrTypes: MultihomingValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"lacp":        lacp,
			"min_links":   v.MinLinks,
			"multihoming": multihoming,
			"type":        v.LagType,
		})

	return objVal, diags
}

func (v LagValue) Equal(o attr.Value) bool {
	other, ok := o.(LagValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Lacp.Equal(other.Lacp) {
		return false
	}

	if !v.MinLinks.Equal(other.MinLinks) {
		return false
	}

	if !v.Multihoming.Equal(other.Multihoming) {
		return false
	}

	if !v.LagType.Equal(other.LagType) {
		return false
	}

	return true
}

func (v LagValue) Type(ctx context.Context) attr.Type {
	return LagType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LagValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"lacp": basetypes.ObjectType{
			AttrTypes: LacpValue{}.AttributeTypes(ctx),
		},
		"min_links": basetypes.Int64Type{},
		"multihoming": basetypes.ObjectType{
			AttrTypes: MultihomingValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LacpType{}

type LacpType struct {
	basetypes.ObjectType
}

func (t LacpType) Equal(o attr.Type) bool {
	other, ok := o.(LacpType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LacpType) String() string {
	return "LacpType"
}

func (t LacpType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	adminKeyAttribute, ok := attributes["admin_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`admin_key is missing from object`)

		return nil, diags
	}

	adminKeyVal, ok := adminKeyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`admin_key expected to be basetypes.Int64Value, was: %T`, adminKeyAttribute))
	}

	intervalAttribute, ok := attributes["interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval is missing from object`)

		return nil, diags
	}

	intervalVal, ok := intervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval expected to be basetypes.StringValue, was: %T`, intervalAttribute))
	}

	lacpFallbackAttribute, ok := attributes["lacp_fallback"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lacp_fallback is missing from object`)

		return nil, diags
	}

	lacpFallbackVal, ok := lacpFallbackAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lacp_fallback expected to be basetypes.ObjectValue, was: %T`, lacpFallbackAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return nil, diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	systemIdMacAttribute, ok := attributes["system_id_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_id_mac is missing from object`)

		return nil, diags
	}

	systemIdMacVal, ok := systemIdMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_id_mac expected to be basetypes.StringValue, was: %T`, systemIdMacAttribute))
	}

	systemPriorityAttribute, ok := attributes["system_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_priority is missing from object`)

		return nil, diags
	}

	systemPriorityVal, ok := systemPriorityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_priority expected to be basetypes.Int64Value, was: %T`, systemPriorityAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LacpValue{
		AdminKey:       adminKeyVal,
		Interval:       intervalVal,
		LacpFallback:   lacpFallbackVal,
		Mode:           modeVal,
		SystemIdMac:    systemIdMacVal,
		SystemPriority: systemPriorityVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewLacpValueNull() LacpValue {
	return LacpValue{
		state: attr.ValueStateNull,
	}
}

func NewLacpValueUnknown() LacpValue {
	return LacpValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLacpValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LacpValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LacpValue Attribute Value",
				"While creating a LacpValue value, a missing attribute value was detected. "+
					"A LacpValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LacpValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LacpValue Attribute Type",
				"While creating a LacpValue value, an invalid attribute value was detected. "+
					"A LacpValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LacpValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LacpValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LacpValue Attribute Value",
				"While creating a LacpValue value, an extra attribute value was detected. "+
					"A LacpValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LacpValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLacpValueUnknown(), diags
	}

	adminKeyAttribute, ok := attributes["admin_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`admin_key is missing from object`)

		return NewLacpValueUnknown(), diags
	}

	adminKeyVal, ok := adminKeyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`admin_key expected to be basetypes.Int64Value, was: %T`, adminKeyAttribute))
	}

	intervalAttribute, ok := attributes["interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval is missing from object`)

		return NewLacpValueUnknown(), diags
	}

	intervalVal, ok := intervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval expected to be basetypes.StringValue, was: %T`, intervalAttribute))
	}

	lacpFallbackAttribute, ok := attributes["lacp_fallback"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lacp_fallback is missing from object`)

		return NewLacpValueUnknown(), diags
	}

	lacpFallbackVal, ok := lacpFallbackAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lacp_fallback expected to be basetypes.ObjectValue, was: %T`, lacpFallbackAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return NewLacpValueUnknown(), diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	systemIdMacAttribute, ok := attributes["system_id_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_id_mac is missing from object`)

		return NewLacpValueUnknown(), diags
	}

	systemIdMacVal, ok := systemIdMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_id_mac expected to be basetypes.StringValue, was: %T`, systemIdMacAttribute))
	}

	systemPriorityAttribute, ok := attributes["system_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_priority is missing from object`)

		return NewLacpValueUnknown(), diags
	}

	systemPriorityVal, ok := systemPriorityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_priority expected to be basetypes.Int64Value, was: %T`, systemPriorityAttribute))
	}

	if diags.HasError() {
		return NewLacpValueUnknown(), diags
	}

	return LacpValue{
		AdminKey:       adminKeyVal,
		Interval:       intervalVal,
		LacpFallback:   lacpFallbackVal,
		Mode:           modeVal,
		SystemIdMac:    systemIdMacVal,
		SystemPriority: systemPriorityVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewLacpValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LacpValue {
	object, diags := NewLacpValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLacpValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LacpType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLacpValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLacpValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLacpValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLacpValueMust(LacpValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LacpType) ValueType(ctx context.Context) attr.Value {
	return LacpValue{}
}

var _ basetypes.ObjectValuable = LacpValue{}

type LacpValue struct {
	AdminKey       basetypes.Int64Value  `tfsdk:"admin_key"`
	Interval       basetypes.StringValue `tfsdk:"interval"`
	LacpFallback   basetypes.ObjectValue `tfsdk:"lacp_fallback"`
	Mode           basetypes.StringValue `tfsdk:"mode"`
	SystemIdMac    basetypes.StringValue `tfsdk:"system_id_mac"`
	SystemPriority basetypes.Int64Value  `tfsdk:"system_priority"`
	state          attr.ValueState
}

func (v LacpValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["admin_key"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["interval"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lacp_fallback"] = basetypes.ObjectType{
		AttrTypes: LacpFallbackValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["system_id_mac"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["system_priority"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.AdminKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["admin_key"] = val

		val, err = v.Interval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interval"] = val

		val, err = v.LacpFallback.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lacp_fallback"] = val

		val, err = v.Mode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mode"] = val

		val, err = v.SystemIdMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_id_mac"] = val

		val, err = v.SystemPriority.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_priority"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LacpValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LacpValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LacpValue) String() string {
	return "LacpValue"
}

func (v LacpValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var lacpFallback basetypes.ObjectValue

	if v.LacpFallback.IsNull() {
		lacpFallback = types.ObjectNull(
			LacpFallbackValue{}.AttributeTypes(ctx),
		)
	}

	if v.LacpFallback.IsUnknown() {
		lacpFallback = types.ObjectUnknown(
			LacpFallbackValue{}.AttributeTypes(ctx),
		)
	}

	if !v.LacpFallback.IsNull() && !v.LacpFallback.IsUnknown() {
		lacpFallback = types.ObjectValueMust(
			LacpFallbackValue{}.AttributeTypes(ctx),
			v.LacpFallback.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"admin_key": basetypes.Int64Type{},
		"interval":  basetypes.StringType{},
		"lacp_fallback": basetypes.ObjectType{
			AttrTypes: LacpFallbackValue{}.AttributeTypes(ctx),
		},
		"mode":            basetypes.StringType{},
		"system_id_mac":   basetypes.StringType{},
		"system_priority": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"admin_key":       v.AdminKey,
			"interval":        v.Interval,
			"lacp_fallback":   lacpFallback,
			"mode":            v.Mode,
			"system_id_mac":   v.SystemIdMac,
			"system_priority": v.SystemPriority,
		})

	return objVal, diags
}

func (v LacpValue) Equal(o attr.Value) bool {
	other, ok := o.(LacpValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdminKey.Equal(other.AdminKey) {
		return false
	}

	if !v.Interval.Equal(other.Interval) {
		return false
	}

	if !v.LacpFallback.Equal(other.LacpFallback) {
		return false
	}

	if !v.Mode.Equal(other.Mode) {
		return false
	}

	if !v.SystemIdMac.Equal(other.SystemIdMac) {
		return false
	}

	if !v.SystemPriority.Equal(other.SystemPriority) {
		return false
	}

	return true
}

func (v LacpValue) Type(ctx context.Context) attr.Type {
	return LacpType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LacpValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"admin_key": basetypes.Int64Type{},
		"interval":  basetypes.StringType{},
		"lacp_fallback": basetypes.ObjectType{
			AttrTypes: LacpFallbackValue{}.AttributeTypes(ctx),
		},
		"mode":            basetypes.StringType{},
		"system_id_mac":   basetypes.StringType{},
		"system_priority": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = LacpFallbackType{}

type LacpFallbackType struct {
	basetypes.ObjectType
}

func (t LacpFallbackType) Equal(o attr.Type) bool {
	other, ok := o.(LacpFallbackType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LacpFallbackType) String() string {
	return "LacpFallbackType"
}

func (t LacpFallbackType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return nil, diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return nil, diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.Int64Value, was: %T`, timeoutAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LacpFallbackValue{
		Mode:    modeVal,
		Timeout: timeoutVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewLacpFallbackValueNull() LacpFallbackValue {
	return LacpFallbackValue{
		state: attr.ValueStateNull,
	}
}

func NewLacpFallbackValueUnknown() LacpFallbackValue {
	return LacpFallbackValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLacpFallbackValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LacpFallbackValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LacpFallbackValue Attribute Value",
				"While creating a LacpFallbackValue value, a missing attribute value was detected. "+
					"A LacpFallbackValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LacpFallbackValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LacpFallbackValue Attribute Type",
				"While creating a LacpFallbackValue value, an invalid attribute value was detected. "+
					"A LacpFallbackValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LacpFallbackValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LacpFallbackValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LacpFallbackValue Attribute Value",
				"While creating a LacpFallbackValue value, an extra attribute value was detected. "+
					"A LacpFallbackValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LacpFallbackValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLacpFallbackValueUnknown(), diags
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return NewLacpFallbackValueUnknown(), diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return NewLacpFallbackValueUnknown(), diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.Int64Value, was: %T`, timeoutAttribute))
	}

	if diags.HasError() {
		return NewLacpFallbackValueUnknown(), diags
	}

	return LacpFallbackValue{
		Mode:    modeVal,
		Timeout: timeoutVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewLacpFallbackValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LacpFallbackValue {
	object, diags := NewLacpFallbackValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLacpFallbackValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LacpFallbackType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLacpFallbackValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLacpFallbackValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLacpFallbackValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLacpFallbackValueMust(LacpFallbackValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LacpFallbackType) ValueType(ctx context.Context) attr.Value {
	return LacpFallbackValue{}
}

var _ basetypes.ObjectValuable = LacpFallbackValue{}

type LacpFallbackValue struct {
	Mode    basetypes.StringValue `tfsdk:"mode"`
	Timeout basetypes.Int64Value  `tfsdk:"timeout"`
	state   attr.ValueState
}

func (v LacpFallbackValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["timeout"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Mode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mode"] = val

		val, err = v.Timeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timeout"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LacpFallbackValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LacpFallbackValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LacpFallbackValue) String() string {
	return "LacpFallbackValue"
}

func (v LacpFallbackValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"mode":    basetypes.StringType{},
		"timeout": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"mode":    v.Mode,
			"timeout": v.Timeout,
		})

	return objVal, diags
}

func (v LacpFallbackValue) Equal(o attr.Value) bool {
	other, ok := o.(LacpFallbackValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Mode.Equal(other.Mode) {
		return false
	}

	if !v.Timeout.Equal(other.Timeout) {
		return false
	}

	return true
}

func (v LacpFallbackValue) Type(ctx context.Context) attr.Type {
	return LacpFallbackType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LacpFallbackValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"mode":    basetypes.StringType{},
		"timeout": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = MultihomingType{}

type MultihomingType struct {
	basetypes.ObjectType
}

func (t MultihomingType) Equal(o attr.Type) bool {
	other, ok := o.(MultihomingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MultihomingType) String() string {
	return "MultihomingType"
}

func (t MultihomingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	esiAttribute, ok := attributes["esi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`esi is missing from object`)

		return nil, diags
	}

	esiVal, ok := esiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`esi expected to be basetypes.StringValue, was: %T`, esiAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return nil, diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	preferredActiveNodeAttribute, ok := attributes["preferred_active_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preferred_active_node is missing from object`)

		return nil, diags
	}

	preferredActiveNodeVal, ok := preferredActiveNodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preferred_active_node expected to be basetypes.StringValue, was: %T`, preferredActiveNodeAttribute))
	}

	reloadDelayTimerAttribute, ok := attributes["reload_delay_timer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reload_delay_timer is missing from object`)

		return nil, diags
	}

	reloadDelayTimerVal, ok := reloadDelayTimerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reload_delay_timer expected to be basetypes.Int64Value, was: %T`, reloadDelayTimerAttribute))
	}

	revertiveAttribute, ok := attributes["revertive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`revertive is missing from object`)

		return nil, diags
	}

	revertiveVal, ok := revertiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`revertive expected to be basetypes.BoolValue, was: %T`, revertiveAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MultihomingValue{
		Esi:                 esiVal,
		Mode:                modeVal,
		PreferredActiveNode: preferredActiveNodeVal,
		ReloadDelayTimer:    reloadDelayTimerVal,
		Revertive:           revertiveVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewMultihomingValueNull() MultihomingValue {
	return MultihomingValue{
		state: attr.ValueStateNull,
	}
}

func NewMultihomingValueUnknown() MultihomingValue {
	return MultihomingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMultihomingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MultihomingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MultihomingValue Attribute Value",
				"While creating a MultihomingValue value, a missing attribute value was detected. "+
					"A MultihomingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MultihomingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MultihomingValue Attribute Type",
				"While creating a MultihomingValue value, an invalid attribute value was detected. "+
					"A MultihomingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MultihomingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MultihomingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MultihomingValue Attribute Value",
				"While creating a MultihomingValue value, an extra attribute value was detected. "+
					"A MultihomingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MultihomingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMultihomingValueUnknown(), diags
	}

	esiAttribute, ok := attributes["esi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`esi is missing from object`)

		return NewMultihomingValueUnknown(), diags
	}

	esiVal, ok := esiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`esi expected to be basetypes.StringValue, was: %T`, esiAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return NewMultihomingValueUnknown(), diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	preferredActiveNodeAttribute, ok := attributes["preferred_active_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preferred_active_node is missing from object`)

		return NewMultihomingValueUnknown(), diags
	}

	preferredActiveNodeVal, ok := preferredActiveNodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preferred_active_node expected to be basetypes.StringValue, was: %T`, preferredActiveNodeAttribute))
	}

	reloadDelayTimerAttribute, ok := attributes["reload_delay_timer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reload_delay_timer is missing from object`)

		return NewMultihomingValueUnknown(), diags
	}

	reloadDelayTimerVal, ok := reloadDelayTimerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reload_delay_timer expected to be basetypes.Int64Value, was: %T`, reloadDelayTimerAttribute))
	}

	revertiveAttribute, ok := attributes["revertive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`revertive is missing from object`)

		return NewMultihomingValueUnknown(), diags
	}

	revertiveVal, ok := revertiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`revertive expected to be basetypes.BoolValue, was: %T`, revertiveAttribute))
	}

	if diags.HasError() {
		return NewMultihomingValueUnknown(), diags
	}

	return MultihomingValue{
		Esi:                 esiVal,
		Mode:                modeVal,
		PreferredActiveNode: preferredActiveNodeVal,
		ReloadDelayTimer:    reloadDelayTimerVal,
		Revertive:           revertiveVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewMultihomingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MultihomingValue {
	object, diags := NewMultihomingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMultihomingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MultihomingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMultihomingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMultihomingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMultihomingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMultihomingValueMust(MultihomingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MultihomingType) ValueType(ctx context.Context) attr.Value {
	return MultihomingValue{}
}

var _ basetypes.ObjectValuable = MultihomingValue{}

type MultihomingValue struct {
	Esi                 basetypes.StringValue `tfsdk:"esi"`
	Mode                basetypes.StringValue `tfsdk:"mode"`
	PreferredActiveNode basetypes.StringValue `tfsdk:"preferred_active_node"`
	ReloadDelayTimer    basetypes.Int64Value  `tfsdk:"reload_delay_timer"`
	Revertive           basetypes.BoolValue   `tfsdk:"revertive"`
	state               attr.ValueState
}

func (v MultihomingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["esi"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["preferred_active_node"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reload_delay_timer"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["revertive"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Esi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["esi"] = val

		val, err = v.Mode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mode"] = val

		val, err = v.PreferredActiveNode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preferred_active_node"] = val

		val, err = v.ReloadDelayTimer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reload_delay_timer"] = val

		val, err = v.Revertive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["revertive"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MultihomingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MultihomingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MultihomingValue) String() string {
	return "MultihomingValue"
}

func (v MultihomingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"esi":                   basetypes.StringType{},
		"mode":                  basetypes.StringType{},
		"preferred_active_node": basetypes.StringType{},
		"reload_delay_timer":    basetypes.Int64Type{},
		"revertive":             basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"esi":                   v.Esi,
			"mode":                  v.Mode,
			"preferred_active_node": v.PreferredActiveNode,
			"reload_delay_timer":    v.ReloadDelayTimer,
			"revertive":             v.Revertive,
		})

	return objVal, diags
}

func (v MultihomingValue) Equal(o attr.Value) bool {
	other, ok := o.(MultihomingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Esi.Equal(other.Esi) {
		return false
	}

	if !v.Mode.Equal(other.Mode) {
		return false
	}

	if !v.PreferredActiveNode.Equal(other.PreferredActiveNode) {
		return false
	}

	if !v.ReloadDelayTimer.Equal(other.ReloadDelayTimer) {
		return false
	}

	if !v.Revertive.Equal(other.Revertive) {
		return false
	}

	return true
}

func (v MultihomingValue) Type(ctx context.Context) attr.Type {
	return MultihomingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MultihomingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"esi":                   basetypes.StringType{},
		"mode":                  basetypes.StringType{},
		"preferred_active_node": basetypes.StringType{},
		"reload_delay_timer":    basetypes.Int64Type{},
		"revertive":             basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = MembersType{}

type MembersType struct {
	basetypes.ObjectType
}

func (t MembersType) Equal(o attr.Type) bool {
	other, ok := o.(MembersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MembersType) String() string {
	return "MembersType"
}

func (t MembersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aggregateIdAttribute, ok := attributes["aggregate_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregate_id is missing from object`)

		return nil, diags
	}

	aggregateIdVal, ok := aggregateIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregate_id expected to be basetypes.StringValue, was: %T`, aggregateIdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return nil, diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	lacpPortPriorityAttribute, ok := attributes["lacp_port_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lacp_port_priority is missing from object`)

		return nil, diags
	}

	lacpPortPriorityVal, ok := lacpPortPriorityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lacp_port_priority expected to be basetypes.Int64Value, was: %T`, lacpPortPriorityAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MembersValue{
		AggregateId:      aggregateIdVal,
		Description:      descriptionVal,
		Enabled:          enabledVal,
		Interface:        interfaceVal,
		LacpPortPriority: lacpPortPriorityVal,
		Node:             nodeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewMembersValueNull() MembersValue {
	return MembersValue{
		state: attr.ValueStateNull,
	}
}

func NewMembersValueUnknown() MembersValue {
	return MembersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMembersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MembersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MembersValue Attribute Value",
				"While creating a MembersValue value, a missing attribute value was detected. "+
					"A MembersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MembersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MembersValue Attribute Type",
				"While creating a MembersValue value, an invalid attribute value was detected. "+
					"A MembersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MembersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MembersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MembersValue Attribute Value",
				"While creating a MembersValue value, an extra attribute value was detected. "+
					"A MembersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MembersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMembersValueUnknown(), diags
	}

	aggregateIdAttribute, ok := attributes["aggregate_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregate_id is missing from object`)

		return NewMembersValueUnknown(), diags
	}

	aggregateIdVal, ok := aggregateIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregate_id expected to be basetypes.StringValue, was: %T`, aggregateIdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewMembersValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewMembersValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return NewMembersValueUnknown(), diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	lacpPortPriorityAttribute, ok := attributes["lacp_port_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lacp_port_priority is missing from object`)

		return NewMembersValueUnknown(), diags
	}

	lacpPortPriorityVal, ok := lacpPortPriorityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lacp_port_priority expected to be basetypes.Int64Value, was: %T`, lacpPortPriorityAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewMembersValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	if diags.HasError() {
		return NewMembersValueUnknown(), diags
	}

	return MembersValue{
		AggregateId:      aggregateIdVal,
		Description:      descriptionVal,
		Enabled:          enabledVal,
		Interface:        interfaceVal,
		LacpPortPriority: lacpPortPriorityVal,
		Node:             nodeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewMembersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MembersValue {
	object, diags := NewMembersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMembersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MembersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMembersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMembersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMembersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMembersValueMust(MembersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MembersType) ValueType(ctx context.Context) attr.Value {
	return MembersValue{}
}

var _ basetypes.ObjectValuable = MembersValue{}

type MembersValue struct {
	AggregateId      basetypes.StringValue `tfsdk:"aggregate_id"`
	Description      basetypes.StringValue `tfsdk:"description"`
	Enabled          basetypes.BoolValue   `tfsdk:"enabled"`
	Interface        basetypes.StringValue `tfsdk:"interface"`
	LacpPortPriority basetypes.Int64Value  `tfsdk:"lacp_port_priority"`
	Node             basetypes.StringValue `tfsdk:"node"`
	state            attr.ValueState
}

func (v MembersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["aggregate_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lacp_port_priority"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.AggregateId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aggregate_id"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Interface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface"] = val

		val, err = v.LacpPortPriority.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lacp_port_priority"] = val

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MembersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MembersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MembersValue) String() string {
	return "MembersValue"
}

func (v MembersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"aggregate_id":       basetypes.StringType{},
		"description":        basetypes.StringType{},
		"enabled":            basetypes.BoolType{},
		"interface":          basetypes.StringType{},
		"lacp_port_priority": basetypes.Int64Type{},
		"node":               basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"aggregate_id":       v.AggregateId,
			"description":        v.Description,
			"enabled":            v.Enabled,
			"interface":          v.Interface,
			"lacp_port_priority": v.LacpPortPriority,
			"node":               v.Node,
		})

	return objVal, diags
}

func (v MembersValue) Equal(o attr.Value) bool {
	other, ok := o.(MembersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AggregateId.Equal(other.AggregateId) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Interface.Equal(other.Interface) {
		return false
	}

	if !v.LacpPortPriority.Equal(other.LacpPortPriority) {
		return false
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	return true
}

func (v MembersValue) Type(ctx context.Context) attr.Type {
	return MembersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MembersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"aggregate_id":       basetypes.StringType{},
		"description":        basetypes.StringType{},
		"enabled":            basetypes.BoolType{},
		"interface":          basetypes.StringType{},
		"lacp_port_priority": basetypes.Int64Type{},
		"node":               basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	lag1Attribute, ok := attributes["lag_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lag_1 is missing from object`)

		return nil, diags
	}

	lag1Val, ok := lag1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lag_1 expected to be basetypes.ObjectValue, was: %T`, lag1Attribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return nil, diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	members1Attribute, ok := attributes["members_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`members_1 is missing from object`)

		return nil, diags
	}

	members1Val, ok := members1Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`members_1 expected to be basetypes.ListValue, was: %T`, members1Attribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return nil, diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return nil, diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		Enabled:          enabledVal,
		Lag1:             lag1Val,
		LastChange:       lastChangeVal,
		Members1:         members1Val,
		OperationalState: operationalStateVal,
		Speed:            speedVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	lag1Attribute, ok := attributes["lag_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lag_1 is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lag1Val, ok := lag1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lag_1 expected to be basetypes.ObjectValue, was: %T`, lag1Attribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	members1Attribute, ok := attributes["members_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`members_1 is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	members1Val, ok := members1Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`members_1 expected to be basetypes.ListValue, was: %T`, members1Attribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		Enabled:          enabledVal,
		Lag1:             lag1Val,
		LastChange:       lastChangeVal,
		Members1:         members1Val,
		OperationalState: operationalStateVal,
		Speed:            speedVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	Enabled          basetypes.BoolValue   `tfsdk:"enabled"`
	Lag1             basetypes.ObjectValue `tfsdk:"lag_1"`
	LastChange       basetypes.StringValue `tfsdk:"last_change"`
	Members1         basetypes.ListValue   `tfsdk:"members_1"`
	OperationalState basetypes.StringValue `tfsdk:"operational_state"`
	Speed            basetypes.StringValue `tfsdk:"speed"`
	state            attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["lag_1"] = basetypes.ObjectType{
		AttrTypes: Lag1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["last_change"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["members_1"] = basetypes.ListType{
		ElemType: Members1Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["operational_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["speed"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Lag1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lag_1"] = val

		val, err = v.LastChange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_change"] = val

		val, err = v.Members1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["members_1"] = val

		val, err = v.OperationalState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operational_state"] = val

		val, err = v.Speed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["speed"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var lag1 basetypes.ObjectValue

	if v.Lag1.IsNull() {
		lag1 = types.ObjectNull(
			Lag1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Lag1.IsUnknown() {
		lag1 = types.ObjectUnknown(
			Lag1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Lag1.IsNull() && !v.Lag1.IsUnknown() {
		lag1 = types.ObjectValueMust(
			Lag1Value{}.AttributeTypes(ctx),
			v.Lag1.Attributes(),
		)
	}

	members1 := types.ListValueMust(
		Members1Type{
			basetypes.ObjectType{
				AttrTypes: Members1Value{}.AttributeTypes(ctx),
			},
		},
		v.Members1.Elements(),
	)

	if v.Members1.IsNull() {
		members1 = types.ListNull(
			Members1Type{
				basetypes.ObjectType{
					AttrTypes: Members1Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Members1.IsUnknown() {
		members1 = types.ListUnknown(
			Members1Type{
				basetypes.ObjectType{
					AttrTypes: Members1Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"lag_1": basetypes.ObjectType{
			AttrTypes: Lag1Value{}.AttributeTypes(ctx),
		},
		"last_change": basetypes.StringType{},
		"members_1": basetypes.ListType{
			ElemType: Members1Value{}.Type(ctx),
		},
		"operational_state": basetypes.StringType{},
		"speed":             basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":           v.Enabled,
			"lag_1":             lag1,
			"last_change":       v.LastChange,
			"members_1":         members1,
			"operational_state": v.OperationalState,
			"speed":             v.Speed,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Lag1.Equal(other.Lag1) {
		return false
	}

	if !v.LastChange.Equal(other.LastChange) {
		return false
	}

	if !v.Members1.Equal(other.Members1) {
		return false
	}

	if !v.OperationalState.Equal(other.OperationalState) {
		return false
	}

	if !v.Speed.Equal(other.Speed) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"lag_1": basetypes.ObjectType{
			AttrTypes: Lag1Value{}.AttributeTypes(ctx),
		},
		"last_change": basetypes.StringType{},
		"members_1": basetypes.ListType{
			ElemType: Members1Value{}.Type(ctx),
		},
		"operational_state": basetypes.StringType{},
		"speed":             basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Lag1Type{}

type Lag1Type struct {
	basetypes.ObjectType
}

func (t Lag1Type) Equal(o attr.Type) bool {
	other, ok := o.(Lag1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Lag1Type) String() string {
	return "Lag1Type"
}

func (t Lag1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	adminKeyAttribute, ok := attributes["admin_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`admin_key is missing from object`)

		return nil, diags
	}

	adminKeyVal, ok := adminKeyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`admin_key expected to be basetypes.Int64Value, was: %T`, adminKeyAttribute))
	}

	systemIdMacAttribute, ok := attributes["system_id_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_id_mac is missing from object`)

		return nil, diags
	}

	systemIdMacVal, ok := systemIdMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_id_mac expected to be basetypes.StringValue, was: %T`, systemIdMacAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Lag1Value{
		AdminKey:    adminKeyVal,
		SystemIdMac: systemIdMacVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewLag1ValueNull() Lag1Value {
	return Lag1Value{
		state: attr.ValueStateNull,
	}
}

func NewLag1ValueUnknown() Lag1Value {
	return Lag1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewLag1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Lag1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Lag1Value Attribute Value",
				"While creating a Lag1Value value, a missing attribute value was detected. "+
					"A Lag1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Lag1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Lag1Value Attribute Type",
				"While creating a Lag1Value value, an invalid attribute value was detected. "+
					"A Lag1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Lag1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Lag1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Lag1Value Attribute Value",
				"While creating a Lag1Value value, an extra attribute value was detected. "+
					"A Lag1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Lag1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLag1ValueUnknown(), diags
	}

	adminKeyAttribute, ok := attributes["admin_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`admin_key is missing from object`)

		return NewLag1ValueUnknown(), diags
	}

	adminKeyVal, ok := adminKeyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`admin_key expected to be basetypes.Int64Value, was: %T`, adminKeyAttribute))
	}

	systemIdMacAttribute, ok := attributes["system_id_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_id_mac is missing from object`)

		return NewLag1ValueUnknown(), diags
	}

	systemIdMacVal, ok := systemIdMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_id_mac expected to be basetypes.StringValue, was: %T`, systemIdMacAttribute))
	}

	if diags.HasError() {
		return NewLag1ValueUnknown(), diags
	}

	return Lag1Value{
		AdminKey:    adminKeyVal,
		SystemIdMac: systemIdMacVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewLag1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Lag1Value {
	object, diags := NewLag1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLag1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Lag1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLag1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLag1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLag1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLag1ValueMust(Lag1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Lag1Type) ValueType(ctx context.Context) attr.Value {
	return Lag1Value{}
}

var _ basetypes.ObjectValuable = Lag1Value{}

type Lag1Value struct {
	AdminKey    basetypes.Int64Value  `tfsdk:"admin_key"`
	SystemIdMac basetypes.StringValue `tfsdk:"system_id_mac"`
	state       attr.ValueState
}

func (v Lag1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["admin_key"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["system_id_mac"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.AdminKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["admin_key"] = val

		val, err = v.SystemIdMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_id_mac"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Lag1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Lag1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Lag1Value) String() string {
	return "Lag1Value"
}

func (v Lag1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"admin_key":     basetypes.Int64Type{},
		"system_id_mac": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"admin_key":     v.AdminKey,
			"system_id_mac": v.SystemIdMac,
		})

	return objVal, diags
}

func (v Lag1Value) Equal(o attr.Value) bool {
	other, ok := o.(Lag1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdminKey.Equal(other.AdminKey) {
		return false
	}

	if !v.SystemIdMac.Equal(other.SystemIdMac) {
		return false
	}

	return true
}

func (v Lag1Value) Type(ctx context.Context) attr.Type {
	return Lag1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Lag1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"admin_key":     basetypes.Int64Type{},
		"system_id_mac": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Members1Type{}

type Members1Type struct {
	basetypes.ObjectType
}

func (t Members1Type) Equal(o attr.Type) bool {
	other, ok := o.(Members1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Members1Type) String() string {
	return "Members1Type"
}

func (t Members1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return nil, diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return nil, diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	neighborsAttribute, ok := attributes["neighbors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbors is missing from object`)

		return nil, diags
	}

	neighborsVal, ok := neighborsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbors expected to be basetypes.ListValue, was: %T`, neighborsAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	nodeInterfaceAttribute, ok := attributes["node_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_interface is missing from object`)

		return nil, diags
	}

	nodeInterfaceVal, ok := nodeInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_interface expected to be basetypes.StringValue, was: %T`, nodeInterfaceAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return nil, diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return nil, diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Members1Value{
		Enabled:          enabledVal,
		Interface:        interfaceVal,
		LastChange:       lastChangeVal,
		Neighbors:        neighborsVal,
		Node:             nodeVal,
		NodeInterface:    nodeInterfaceVal,
		OperationalState: operationalStateVal,
		Speed:            speedVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewMembers1ValueNull() Members1Value {
	return Members1Value{
		state: attr.ValueStateNull,
	}
}

func NewMembers1ValueUnknown() Members1Value {
	return Members1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewMembers1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Members1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Members1Value Attribute Value",
				"While creating a Members1Value value, a missing attribute value was detected. "+
					"A Members1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Members1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Members1Value Attribute Type",
				"While creating a Members1Value value, an invalid attribute value was detected. "+
					"A Members1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Members1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Members1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Members1Value Attribute Value",
				"While creating a Members1Value value, an extra attribute value was detected. "+
					"A Members1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Members1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMembers1ValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewMembers1ValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return NewMembers1ValueUnknown(), diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return NewMembers1ValueUnknown(), diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	neighborsAttribute, ok := attributes["neighbors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbors is missing from object`)

		return NewMembers1ValueUnknown(), diags
	}

	neighborsVal, ok := neighborsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbors expected to be basetypes.ListValue, was: %T`, neighborsAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewMembers1ValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	nodeInterfaceAttribute, ok := attributes["node_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_interface is missing from object`)

		return NewMembers1ValueUnknown(), diags
	}

	nodeInterfaceVal, ok := nodeInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_interface expected to be basetypes.StringValue, was: %T`, nodeInterfaceAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return NewMembers1ValueUnknown(), diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return NewMembers1ValueUnknown(), diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	if diags.HasError() {
		return NewMembers1ValueUnknown(), diags
	}

	return Members1Value{
		Enabled:          enabledVal,
		Interface:        interfaceVal,
		LastChange:       lastChangeVal,
		Neighbors:        neighborsVal,
		Node:             nodeVal,
		NodeInterface:    nodeInterfaceVal,
		OperationalState: operationalStateVal,
		Speed:            speedVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewMembers1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Members1Value {
	object, diags := NewMembers1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMembers1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Members1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMembers1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMembers1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMembers1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMembers1ValueMust(Members1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Members1Type) ValueType(ctx context.Context) attr.Value {
	return Members1Value{}
}

var _ basetypes.ObjectValuable = Members1Value{}

type Members1Value struct {
	Enabled          basetypes.BoolValue   `tfsdk:"enabled"`
	Interface        basetypes.StringValue `tfsdk:"interface"`
	LastChange       basetypes.StringValue `tfsdk:"last_change"`
	Neighbors        basetypes.ListValue   `tfsdk:"neighbors"`
	Node             basetypes.StringValue `tfsdk:"node"`
	NodeInterface    basetypes.StringValue `tfsdk:"node_interface"`
	OperationalState basetypes.StringValue `tfsdk:"operational_state"`
	Speed            basetypes.StringValue `tfsdk:"speed"`
	state            attr.ValueState
}

func (v Members1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_change"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["neighbors"] = basetypes.ListType{
		ElemType: NeighborsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node_interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operational_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["speed"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Interface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface"] = val

		val, err = v.LastChange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_change"] = val

		val, err = v.Neighbors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["neighbors"] = val

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		val, err = v.NodeInterface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_interface"] = val

		val, err = v.OperationalState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operational_state"] = val

		val, err = v.Speed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["speed"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Members1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Members1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Members1Value) String() string {
	return "Members1Value"
}

func (v Members1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	neighbors := types.ListValueMust(
		NeighborsType{
			basetypes.ObjectType{
				AttrTypes: NeighborsValue{}.AttributeTypes(ctx),
			},
		},
		v.Neighbors.Elements(),
	)

	if v.Neighbors.IsNull() {
		neighbors = types.ListNull(
			NeighborsType{
				basetypes.ObjectType{
					AttrTypes: NeighborsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Neighbors.IsUnknown() {
		neighbors = types.ListUnknown(
			NeighborsType{
				basetypes.ObjectType{
					AttrTypes: NeighborsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"enabled":     basetypes.BoolType{},
		"interface":   basetypes.StringType{},
		"last_change": basetypes.StringType{},
		"neighbors": basetypes.ListType{
			ElemType: NeighborsValue{}.Type(ctx),
		},
		"node":              basetypes.StringType{},
		"node_interface":    basetypes.StringType{},
		"operational_state": basetypes.StringType{},
		"speed":             basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":           v.Enabled,
			"interface":         v.Interface,
			"last_change":       v.LastChange,
			"neighbors":         neighbors,
			"node":              v.Node,
			"node_interface":    v.NodeInterface,
			"operational_state": v.OperationalState,
			"speed":             v.Speed,
		})

	return objVal, diags
}

func (v Members1Value) Equal(o attr.Value) bool {
	other, ok := o.(Members1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Interface.Equal(other.Interface) {
		return false
	}

	if !v.LastChange.Equal(other.LastChange) {
		return false
	}

	if !v.Neighbors.Equal(other.Neighbors) {
		return false
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	if !v.NodeInterface.Equal(other.NodeInterface) {
		return false
	}

	if !v.OperationalState.Equal(other.OperationalState) {
		return false
	}

	if !v.Speed.Equal(other.Speed) {
		return false
	}

	return true
}

func (v Members1Value) Type(ctx context.Context) attr.Type {
	return Members1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Members1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":     basetypes.BoolType{},
		"interface":   basetypes.StringType{},
		"last_change": basetypes.StringType{},
		"neighbors": basetypes.ListType{
			ElemType: NeighborsValue{}.Type(ctx),
		},
		"node":              basetypes.StringType{},
		"node_interface":    basetypes.StringType{},
		"operational_state": basetypes.StringType{},
		"speed":             basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NeighborsType{}

type NeighborsType struct {
	basetypes.ObjectType
}

func (t NeighborsType) Equal(o attr.Type) bool {
	other, ok := o.(NeighborsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NeighborsType) String() string {
	return "NeighborsType"
}

func (t NeighborsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return nil, diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NeighborsValue{
		Interface: interfaceVal,
		Node:      nodeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewNeighborsValueNull() NeighborsValue {
	return NeighborsValue{
		state: attr.ValueStateNull,
	}
}

func NewNeighborsValueUnknown() NeighborsValue {
	return NeighborsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNeighborsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NeighborsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NeighborsValue Attribute Value",
				"While creating a NeighborsValue value, a missing attribute value was detected. "+
					"A NeighborsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NeighborsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NeighborsValue Attribute Type",
				"While creating a NeighborsValue value, an invalid attribute value was detected. "+
					"A NeighborsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NeighborsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NeighborsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NeighborsValue Attribute Value",
				"While creating a NeighborsValue value, an extra attribute value was detected. "+
					"A NeighborsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NeighborsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNeighborsValueUnknown(), diags
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return NewNeighborsValueUnknown(), diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewNeighborsValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	if diags.HasError() {
		return NewNeighborsValueUnknown(), diags
	}

	return NeighborsValue{
		Interface: interfaceVal,
		Node:      nodeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewNeighborsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NeighborsValue {
	object, diags := NewNeighborsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNeighborsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NeighborsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNeighborsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNeighborsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNeighborsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNeighborsValueMust(NeighborsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NeighborsType) ValueType(ctx context.Context) attr.Value {
	return NeighborsValue{}
}

var _ basetypes.ObjectValuable = NeighborsValue{}

type NeighborsValue struct {
	Interface basetypes.StringValue `tfsdk:"interface"`
	Node      basetypes.StringValue `tfsdk:"node"`
	state     attr.ValueState
}

func (v NeighborsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Interface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface"] = val

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NeighborsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NeighborsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NeighborsValue) String() string {
	return "NeighborsValue"
}

func (v NeighborsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"interface": basetypes.StringType{},
		"node":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"interface": v.Interface,
			"node":      v.Node,
		})

	return objVal, diags
}

func (v NeighborsValue) Equal(o attr.Value) bool {
	other, ok := o.(NeighborsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Interface.Equal(other.Interface) {
		return false
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	return true
}

func (v NeighborsValue) Type(ctx context.Context) attr.Type {
	return NeighborsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NeighborsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"interface": basetypes.StringType{},
		"node":      basetypes.StringType{},
	}
}
